---
title: "특정 거리의 도시 찾기"
date: 2026-01-05
categories: [코딩테스트]
tags: [다익스트라]
---

# 특정 거리의 도시 찾기

## 문제
어떤 나라에는 1번부터 N번까지의 도시와 M개의 **단방향 도로**가 존재한다.  
모든 도로의 거리는 **1**이다.

이때 특정한 도시 **X**로부터 출발하여 도달할 수 있는 모든 도시 중에서,  
**최단 거리가 정확히 K인** 모든 도시들의 번호를 출력하는 프로그램을 작성하시오.

또한 출발 도시 **X**에서 출발 도시 **X**로 가는 최단 거리는 항상 **0**이라고 가정한다.<br>
<img width="495" height="493" alt="image" src="https://github.com/user-attachments/assets/d14f1981-ee4e-49ac-824f-4c6206988f81" /> <br>




### 예시 설명
예를 들어 `N = 4`, `K = 2`, `X = 1`일 때 그래프가 다음과 같이 구성되어 있다고 가정하자.

이때 1번 도시에서 출발하여 도달할 수 있는 도시 중에서  
최단 거리가 2인 도시는 **4번 도시뿐**이다.

- 2번, 3번 도시는 최단 거리가 1이므로 출력하지 않는다.

---

## 입력
- 첫째 줄에 도시의 개수 **N**, 도로의 개수 **M**, 거리 정보 **K**, 출발 도시 번호 **X**가 주어진다.  
  - `(2 ≤ N ≤ 300,000)`
  - `(1 ≤ M ≤ 1,000,000)`
  - `(1 ≤ K ≤ 300,000)`
  - `(1 ≤ X ≤ N)`

- 둘째 줄부터 **M개의 줄**에 걸쳐 두 개의 자연수 **A, B**가 공백으로 구분되어 주어진다.  
  이는 **A번 도시에서 B번 도시로 이동하는 단방향 도로**가 존재한다는 의미이다.
  - `(1 ≤ A, B ≤ N)`
  - `A ≠ B`

---

## 출력
- **X로부터 출발하여 도달할 수 있는 도시 중에서, 최단 거리가 K인 모든 도시의 번호를**
  **한 줄에 하나씩 오름차순으로 출력**한다.
- 만약 최단 거리가 **K인 도시가 하나도 없다면 `-1`을 출력**한다.

---

## 예제 입력 1
4 4 2 1 <br>
1 2 <br>
1 3 <br>
2 3 <br>
2 4 <br>

---

## 예제 입력 2
4 3 2 1 <br>
1 2 <br>
1 3 <br>
1 4 <br>

---
### 문제 접근
- BFS 사용할거고(좌우 어디로 갈지 고르는 거니까) 그리고 Queue 알아야하고
- 모든 도로의 가중치가 1
- 단방향 그래프
- 구할 식 : 출발 도시 X로부터 최단 거리 K
- 도시의 개수 N, 도로의 개수 M, 거리 정보 K, 출발 도시의 번호 X
- BufferedReader 사용해서 시간복잡도 줄이고
- 무조건 인전리스트 그래프를 그려주고
- 거리 배열 초기화 해주고
- BFS 시작
  - BFS 탐색
    - 거리 K 결과 저장
    - 미방문 노드만 큐에 추가
```java
package studycodingtest.Dijkstra;
    //도시 개수 : N
    //도로의 개수 M
    //목표 거리 K
    //출발 도시 번호 X

    //모든 거리는 1고정, 단방향
 
import org.w3c.dom.Node;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class BOJ_City {
    public static void main(String[] args) throws IOException {

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] inputs = (reader.readLine()).split(" ");
        // 기초 세팅 해주고
        int N = Integer.parseInt(inputs[0]);
        int M = Integer.parseInt(inputs[1]);
        int K = Integer.parseInt(inputs[2]);
        int X = Integer.parseInt(inputs[3]);

        // 인접 리스트 사용하고
        List<Integer>[] arr = new ArrayList[N + 1];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = new ArrayList<Integer>();
        }

        // 도로 정보를 저장해 해주고 (단방향)
        for (int i = 0; i < M; i++) {
            String[] str = reader.readLine().split(" ");
            int A = Integer.parseInt(str[0]); // 출
            int B = Integer.parseInt(str[1]); // 도
            arr[A].add(B);
        }

        // 거리 배열 해서 dis[i] = -1 이면 방문하지 않은 dis[i] >= 0 x에서 i까지의 최단 거리
        int[] dis = new int[N + 1];
        Arrays.fill(dis, -1);
        List<Integer> answer = new ArrayList<>();

        // BFS 초기화 해주고
        Queue<Integer> q = new LinkedList<>();
        q.offer(X);
        dis[X] = 0;

        // BFS 탐색 로직
        while (q.size() != 0) {
            int cur = q.poll();

            // 최단 거리 결과 저장해주고
            if (dis[cur] == K)
                answer.add(cur);

            // 인접 도시 탐색해주고
            for (int i = 0; i < arr[cur].size(); i++) {
                if (arr[cur].get(i) != X && dis[arr[cur].get(i)] == -1) {
                    q.offer(arr[cur].get(i));
                    dis[arr[cur].get(i)] = dis[cur] + 1;
                }
            }
        }

        if (answer.size() == 0) {
            System.out.print("-1");
        } else {
            answer.sort((o1, o2) -> {
                return o1 - o2;
            });

            for (int i = 0; i < answer.size(); i++) {
                System.out.println(answer.get(i));
            }
        }
    }
}

```
