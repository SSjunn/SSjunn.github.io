---
title: "너비우선탐색[BFS]"
date: 2025-12-31
categories: [코딩테스트]
tags: [BFS]
---
- 그래프를 완전 탐색하는 방법 중 하나
- 시작 노드에서 출발해 시작 노드를 기준으로 가까운 노드를 먼저 방문하면서 탐색하는 알고리즘

| 기능 | 특징 | 시간 복잡도 (노드 수: V, 에지 수: E) |
| --- | --- | --- |
| 그래프 완전 탐색 | FIFO 탐색<br> Queue 자료구조 이용  | O(V + E) |

BFS랑 반대 개념

- 선입선출 방식으로 탐색하므로 큐를 이용해 구현
- 탐색 시작 노드와 가까운 노드를 우선하여 탐색하므로 목표 노드에 도착하는 경로가 여러 개일 때 최단 경로를 보장

### 너비 우선 탐색의 동작 원리


1. **BFS를 시작할 노드를 정한 후 사용할 자료구조 초기화 하기**
- BFS도 DFS 와 마찬가지로 방문했던 노드는 다시 방문하지 않으므로 방문한 노드를 체크하기 위한 배열이 필요
- 그래프를 인접 리스트로 표현하는 것 역시 DFS 와 동일
- 차이점은 탐색을 위해 **스택이 아닌 큐**를 사용
<img width="1386" height="499" alt="스크린샷 2025-12-31 025455" src="https://github.com/user-attachments/assets/d29c8647-004f-4f82-90c1-ee7d19f7a930" />


2. **큐에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 큐에 삽입하기**
- 큐에서 노드를 꺼내면서 인접 노드를 큐에 삽입
- 이때 방문 배열을 체크하여 이미 방문한 노드는 큐에 삽입하지 않음
- 꺼낸 노드는 탐색 순서에 기록
<img width="671" height="274" alt="스크린샷 2025-12-31 030331" src="https://github.com/user-attachments/assets/f0345c39-fb02-4479-b806-555afbc5542e" />


3. **큐 자료구조에 값이 없을 때까지 반복**
<img width="1434" height="587" alt="스크린샷 2025-12-31 030447" src="https://github.com/user-attachments/assets/4217d179-ed92-4d94-b8d1-ceb2577789a6" />

### 핵심 자료 구조
- ArrayList<ArrayList<Integer>> : 그래프 (인접 리스트)
- boolean[] visited : 방문 여부 체크
- Queue<Integer> : BFS용 큐

**큐(Queue) 사용 — 탐색 순서 보장**
```java
Queue<Integer> queue = new LinkedList<>();

queue.offer(start);   // 시작 노드 삽입
int current = queue.poll(); // 가장 먼저 들어온 노드 처리 (FIFO)
```
- 먼저 발견한 노드부터 처리하기 때문에 “가까운 노드 → 먼 노드” 순서가 유지


**방문 처리(visited) - 중복 탐색 방지
```java
boolean[] visited = new boolean[n];

visited[start] = true;  // 큐에 넣는 순간 방문 처리

if (!visited[next]) {
    visited[next] = true;
    queue.offer(next);
}
```
- 큐에 넣을 때 방문 처리


**인접 노드 순회 — 확장 탐색**
```java
for (int next : graph.get(current)) {
    if (!visited[next]) {
        visited[next] = true;
        queue.offer(next);
    }
}
```
- 현재 노드 기준으로 **연결된 모든 노드를 한 단계씩 확장**


