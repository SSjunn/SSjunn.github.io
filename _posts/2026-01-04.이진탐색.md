---
title: "이진탐색(바이너리 서치)"
date: 2026-01-04
categories: [코딩테스트]
tags: [이진탐색]
---

- 이진 탐색: 정렬된 데이터 중 공간을 반씩 나눠 제거해 나가는 방식
- 시간복잡도: N log N (데이터가 많을수록 속도 차이가 많이 남)

| 기능 | 특징 | 시간 복잡도 |
| --- | --- | --- |
| 타깃 데이터 탐색 | 중앙값 비교를 통한 대상 축소 방식 | O(logN) |

- **반드시 정렬이 먼저 되어 있어야함**
- 이진 탐색 알고리즘도 자바에서 이미 구현되어 있음
- 배열: Arrays.binarySearch()
- 리스트 : Collections.binarySearch()
    - 개발공부함에 있어 정렬 알고리즘과 더불어 상식적으로 알고 있어야하는 알고리즘
### 동작 원리(개념)
- 이진 탐색: 중간값을 기준으로 절반씩 버리는 사고 방식
- 배열의 중앙 인덱스(mid) 선택
- arr[mid] 와 목표값(target) 비교
    - target < arr[mid] -> 왼쪽 절반 탐색
    - target > arr[mid] -> 오른쪽 절반 탐색
- 탐색 범위(중앙값 == 타깃 데이터)일 때 탐색을 종료
 <img width="964" height="881" alt="스크린샷 2026-01-04 211602" src="https://github.com/user-attachments/assets/ed1a2c4f-76ea-43ad-9c34-6bdf7299f844" />

### 알아야 할 코드

```java
public static int binarySearch(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2; // overflow 방지

        if (arr[mid] == target) {
            return mid; // 찾은 경우
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1; // 못 찾은 경우
}
```
- left <= right<br>
  -> 등호 (=) 없으면 원소 1개 남았을 때 탐색 불가
- mid 계산식<br>
  -> (left + right) / 2 overflow 위험
- 반환값<br>
  -> 보통: "인덱스" 또는 존재 여부(-1)
### 재귀 방식
```java
public static int binarySearchRecursive(int[] arr, int target, int left, int right) {
    if (left > right) {
        return -1;
    }

    int mid = left + (right - left) / 2;

    if (arr[mid] == target) {
        return mid;
    } else if (arr[mid] < target) {
        return binarySearchRecursive(arr, target, mid + 1, right);
    } else {
        return binarySearchRecursive(arr, target, left, mid - 1);
    }
}
```



