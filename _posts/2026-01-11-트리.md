---
title: "트리"
date: 2026-01-11
categories: [코딩테스트]
tags: [트리]
---
# 트리(Tree)
- 트리는 가계도와 같은 계층적인 구조를 표현할 때 사용할 수 있는 자료구조
<img width="300" height="300" alt="image" src="https://github.com/user-attachments/assets/c1f8f388-7080-4318-915c-5365cbab6aca" />

<details>
  <summary>트리 관련 용어</summary>

  <div markdown="1">
  - **루트 노드 (root node)**: 부모가 없는 최상 노드
  - **단말 노드 (leaf node)**: 자식이 없는 노드
  - **크기 (size)**: 트리에 포함된 모든 노드의 개수
  - **깊이 (depth)**: 루트 노드부터의 거리
  - **높이 (height)**: 깊이 중 최댓값
  - **차수 (degree)**: 각 노드의 자식 간선 개수
  </div>

</details>

-  기본적으로 트리의 크기가 N일 때, 전체 간선의 개수는 N-1 개

### 이진 탐색 트리 (Binary Search Tree)
- 이진 탐색이 동작할 수 있도록 고안된 효율적인 탐색이 가능한 자료구조의 일종
- 이진 탐색 트리의 특징 : 왼쪽 자식 노드 &lt; 부모 노드 &lt; 오른쪽 자식 노드
  - 부모 노드보다 왼쪽 자식 노드가 작음
  - 부모 노드보다 오른쪽 자식 노드가 큼
<img width="400" height="400" alt="스크린샷 2026-01-11 173226" src="https://github.com/user-attachments/assets/1eb075f9-b7ea-4ef3-b938-00a67f5220ac" />

### 트리 순회
- 트리 자료구조에 포함된 노드를 특정한 방법으로 한 번씩 방문하는 방법을 의미
  - 트리의 정보를 시각적으로 확인 할 수 있음
- 대표적인 트리 순회 방법
  - 전위 순회(pre-order traverse) : 루트를 먼저 방문
  - 중위 순회(in-order traverse) : 왼쪽 자식을 방문한 뒤에 루트를 방문
  - 후위 순회(post-order traverse) : 오른쪽 자식을 방문한 뒤에 루트를 방문
<img width="2405" height="980" alt="image" src="https://github.com/user-attachments/assets/8219b7e7-36cf-44f9-aed9-c6e48ac97eee" />

**예시 코드**
```java
class TreeNode {
    int value;
    TreeNode left;
    TreeNode right;
    
    TreeNode(int value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
}

public class TreeBasic {
    
    // 전위 순회
    public static void preorder(TreeNode node) {
        if (node == null) return;
        System.out.print(node.value + " ");
        preorder(node.left);
        preorder(node.right);
    }
    
    // 중위 순회
    public static void inorder(TreeNode node) {
        if (node == null) return;
        inorder(node.left);
        System.out.print(node.value + " ");
        inorder(node.right);
    }
    
    // 후위 순회
    public static void postorder(TreeNode node) {
        if (node == null) return;
        postorder(node.left);
        postorder(node.right);
        System.out.print(node.value + " ");
    }
    
    // 트리 높이 구하기
    public static int getHeight(TreeNode node) {
        if (node == null) return 0;
        
        int leftHeight = getHeight(node.left);
        int rightHeight = getHeight(node.right);
        
        // 왼쪽과 오른쪽 중 더 긴 쪽 + 1(나 자신)
        return Math.max(leftHeight, rightHeight) + 1;
    }
    
    // 노드 개수 세기
    public static int countNodes(TreeNode node) {
        if (node == null) return 0;
        
        return 1 + countNodes(node.left) + countNodes(node.right);
    }
    
    public static void main(String[] args) {
        // 트리 만들기
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        
        System.out.println("=== 순회 결과 ===");
        System.out.print("전위 순회: ");
        preorder(root);  // 1 2 4 5 3
        System.out.println();
        
        System.out.print("중위 순회: ");
        inorder(root);   // 4 2 5 1 3
        System.out.println();
        
        System.out.print("후위 순회: ");
        postorder(root); // 4 5 2 3 1
        System.out.println();
        
        System.out.println("\n=== 트리 정보 ===");
        System.out.println("높이: " + getHeight(root));      // 3
        System.out.println("노드 개수: " + countNodes(root)); // 5
    }
}
```


